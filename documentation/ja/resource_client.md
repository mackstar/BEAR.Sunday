---
layout: default_ja
title: BEAR.Sunday | リソースクライント
category: リソース
--- 
# リソースクライント

BEAR.Sundayの各種リソースをリクエストするのがリソースクライントです。リクエストメソッド、URI、引き数等を指定してリソースリクエストを組み立てリソースをリクエストをします。

## 準備 
リソースクライアントを利用クラスはインジェクターからリソースクライアントオブジェクトをインジェクトしてもらうために、リソースクライアントのsetterメソッドを用意します。traitを使うと便利です。

```
use BEAR\Sunday\Inject\ResourceInject;

class Edit extends Page
{
    use ResourceInject;
```

これで`resource`プロパティにリソースクライアントがセットされ、`$this->resource`でリソースクライアントにアクセスできます。

## リクエストDSL 

```
$this
->resource
->get
->uri('app://self/blog/posts')
->withQuery(['id' => 1])
->eager
->request();
```

この例では *`app://self/blog/posts`* リソースに?id=1というリクエストをすぐ(eager)に行います。

リクエストはメソッド、URI、クエリー等各要素で構成されてます。その構成要素を上記のようにDSLで表しリクエストを組み立て実行します。

### リクエストメソッド 

リソースを操作するget, put, post, deleteの4つと、リソースの操作の利用方法を調べるoptions、会わせて5つです。

### リクエストURI 
BEAR.SundayのリソースはwwwのURIと同様な形式を持ちます。

```
{スキーマ}://{アプリケーション}/{パス}
```
{スキーマ}がリソースの種類、を表し、{アプリケーション}は通常自己（アプリケーション）を表すselfを指定します。BEAR.Sundayではページコントローラーもページリソースとして扱われます。その場合のスキーマは`page`です。モデルにあたるアプリケーションリソースのスキーマは`app`です。

トップページは以下の表記になります。(自己selfのアプリケーションの`/index`パスのpageリソースです。)
```
page://self/index
```

sandboxアプリケーションのブログ記事アプリケーションリソースは以下の表記です。
```
app://self/blog/posts
```

page/appスキーマは以下のクラス、ファイルに対応します。

|| URI || Class || File ||
|| page://self/index || Sandbox\Resource\Page\Index ||Sandbox/Resource/Page/Index.php ||
|| app://self/blog/posts || Sandbox\Resource\App\Blog\Posts || Sandbox/Resource/App/Blog/Posts.php ||

オリジナルのスキーマをリソースアダプターとしてアプリケーションサイドで実装することが可能です。例えば既存の"office"サービスが何らかのシステムとして現在動作してるとします。officeスキーマをつくり、そのレガシーサービスをラップするアダプターをつくり、`office://{サービスパス}`等とします。

以前からある情報システムを利用したい場合なども直接オブジェクトを扱うより新しいスキーマを作り、リソースアダプターを利用した方が良いでしょう。

### リクエストクエリー 

リクエストクエリーでは名前付き引数で引数を渡します。これはPHPの通常の順序による引数ではなく、変数名を指定する名前付き引数です。

['id' => 1]とクエリーを指定は以下のリソースリクエストメソッドに対応します。変数名を指定します。その順序は無関係です。

```
public function onGet($id)
{
}
```


リクエストオブジェクトはリクエストに必要な知識をもったオブジェクトです。テンプレートにアサインし、遅延評価することもできます。

### リクエストタイミング 

リソースのリクエストはlazyとeagerがあります。リクエストにlazyがついてないものがeagerリクエストです。

#### lazyリクエスト
```
$this['posts'] = $this->resource->get->uri('app://self/posts')->request();
```

#### eagerリクエスト
```
$this['posts'] = $this->resource->get->uri('app://self/posts')->eager->request();
```

eagerの *ある* リソースリクエストの返り値はリソースリクエストの結果です。eagerの *ない* リソースlazyリクエストの結果はリクエストインターフェイス(BEAR\Resource\Requestable）を実装したリクエストクラスです。

このリクエストをテンプレートにアサインして埋め込むと、その要素が出現した時点ではじめて評価されます。つまりリクエストはビューで使用されなかったらリクエストは行われません。これをリソースの遅延評価（レイジーエバリュエーション）といいます。

### リンク 

リソースはリンクすることができます。リソースの結果を次のリソース入力としてリソースをつなぎます。リスースを入れ替えるselfLink、リソースにリソースを追加するaddLink、複数のリソースにリンクするcrawlLink。

リンク機能はリソース間の関係性をカプセル化します。利用するクライアントは関係性の実際を理解することなく、関係性を利用できます。これはwebのAタグをイメージすれば分かりやすいです。クリック先URLの情報はクライアントでなくサービスが管理していて、利用者はリンクテキストをクリックするだけです。

### EOR(End of Request) 

組み立てたリクエストは`request()`メソッドで閉じます。eagerであれば実行された結果、lazyであればリクエストオブジェクト、このどちらかの値が返ります。

## リソースレンダラー 

リソース状態、つまりリソースの値を表現にするのはリソースが保持するリソースレンダラーの役割です。リソースの利用者ではありません。例えばMVCでコントローラーがモデルからデータを取得してビューに渡すのと違い、リソースはそれぞれ内部にリソースレンダラー持ち自身をどのように表現するかを外部に委ねず自身が決定します。

レンダラーはDependency Injectorによってインジェクトされます。DIの設定を行うアプリケーションモジュールでこのレンダラーを別のレンダラーにする事ができます。例えば開発中は開発情報が付加表示されるDevRendererがインジェクトされています。Web API用には例えばJSONをレンダリングするJsonRendererをインジェクトします。

## リソースレンダリング 

リソースは特にレンダリング用のメソッドを持ちません。文字列として評価するとレンダラーがレンダリングして結果が文字列として返ります。以下は例です。

```
$userHtml = (string) $user; // 型変換
echo $user;
```

## テンプレートでの表記 

|| 文字列 || {$posts} || 結果がテンプレートエンジンでレンダリングされた文字列 || 
|| 配列 || {$posts['id']} || 結果の連想配列アクセス ||
|| オブジェクト || {$posts->header} || 結果のオブジェクトアクセス ||

※eagerでもlazyでもテンプレートの表記に違いはありません。