<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
    	<meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>BEAR.Sunday | リソースアダプター</title>

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/bootstrap.min.css">
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>
    <div id="wrap">
      <div class="container">
        <img src="/img/logo.png" />

        <!-- Static navbar -->
        <div class="navbar navbar-default">
          <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
              <li><a href="#">Documentation</a></li>
              <li><a href="#">Code</a></li>
              </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="/ja">Japanese</a></li>
              <li><a href="/">English</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>




<div class="row">
	<div class="col-md-3">

		<div class="panel panel-default">
	<div class="panel-heading"><strong>リソース</strong></div>
	<div class="panel-body">

	<ul class="nav nav-pills nav-stacked">
		
		

		

		

		
			<li><a href="resource.html">イントロダクション</a></li>
<li><a href="resource_client.html">リソースクライアント</a></li>
<li><a href="resource_object.html">リソースオブジェクト</a></li>
<li><a href="resource_renderer.html">リソースレンダラー</a></li>
<li><a href="resource_link.html">リソースリンク</a></li>
<li><a href="resource_adapter.html">リソースアダプター</a></li>
		
	</ul>
</div>
</div>


	</div>
	<div class="col-md-9">

		 <h1 id="toc_0">リソースアダプター</h1>

<p>リソースの<code>URI</code>のスキーマはアプリケーションによって特定のリソースアダプターとバインドされ、そのリクエストを行います。</p>

<h2 id="toc_1">バインディングDSL</h2>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$schemeCollection = new SchemeCollection;
$schemeCollection-&gt;scheme(&#39;app&#39;)-&gt;host(&#39;self&#39;)-&gt;toAdapter($appAdapter);
$schemeCollection-&gt;scheme(&#39;page&#39;)-&gt;host(&#39;self&#39;)-&gt;toAdapter($pageAdapter);
$schemeCollection-&gt;scheme(&#39;page&#39;)-&gt;host(&#39;*&#39;)-&gt;toAdapter($httpAdapter);
$this-&gt;bind(&#39;BEAR\Resource\SchemeCollection&#39;)-&gt;toInstance($schemeCollection);
</code></pre></div>
<p>上記のバインディングで、<code>app://self/</code>、<code>page://self/</code>および、<code>http://</code>で始まるリソースが扱える様になります。実際にリクエストを処理するのはリソースアダプター（<code>$appAdapter</code>等）です。</p>

<p>このようにURIと特定実装は固定化されたものではなくアプリケーションのバインディングによって決定されます。</p>

<h2 id="toc_2">リソースアダプター</h2>

<p>リソースアダプターは実際にはリソースオブジェクトのファクトリーです。<code>BEAR\Resource\Provider</code>メソッドを実装してリソースオブジェクトを返します。</p>

<p>例えば<code>app</code>, <code>page</code>なら<code>URI</code>からクラス名を特定してのリソースオブジェクトクラスをインスタンスにして返します。<code>http</code>なら<code>HTTP Clientサービス</code>を代理実行するオブジェクトです。</p>

<p>メソッドに対応する<code>onGet</code>等のメソッド名がリソースの状態を返します。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">App implements ResourceObject, Provider, Adapter
{
    private $injector;
    private $namespace;
    private $path;

    /**
     * Constructor
     *
     * @param InjectorInterface $injector  Application dependency injector
     * @param string            $namespace Resource adapter namespace
     * @param string            $path      Resource adapter path
     *
     * @Inject
     */
    public function __construct(
        InjectorInterface $injector,
        $namespace,
        $path
    ){
        if (! is_string($namespace)) {
            throw new RuntimeException(&#39;namespace not string&#39;);
        }
        $this-&gt;injector = $injector;
        $this-&gt;namespace = $namespace;
        $this-&gt;path = $path;
    }

    /**
     * (non-PHPdoc)
     *
     * @see    BEAR\Resource.Provider::get()
     * @return object
     * @throws Exception\Host
     */
    public function get($uri)
    {
        $parsedUrl = parse_url($uri);
        $path = str_replace(&#39;/&#39;, &#39; &#39;, $parsedUrl[&#39;path&#39;]);
        $path = ucwords($path);
        $path = str_replace(&#39; &#39;, &#39;\\&#39;, $path);
        $host = $parsedUrl[&#39;host&#39;];
        $className = &quot;{$this-&gt;namespace}\\{$this-&gt;path}{$path}&quot;;
        $instance = $this-&gt;injector-&gt;getInstance($className);

        return $instance;
    }
}
</code></pre></div>
<p><em>コンストラクタでリソースオブジェクトのベースディリクトリやインジェクターをインジェクトしてもらって、その依存解決を行いインスタンスにして返します。<code>app</code>も<code>page</code>も保存場所だけが違う同じものです。</em></p>

<h2 id="toc_3">複数アプリケーションのリソース</h2>

<p>インジェクターはオブジェクトの構成知識の全てを持っています。ですので、違うアプリケーションのインジェクターを入手することができれば、同一インスタンスで複数のアプリケーションのリソースを扱うことが可能になります。</p>

<p>例えばプロジェクトを横断するようなアプリケーションや、組織内の認証API等です。HTTPやThrift等ネットワーク越しでなく、同一インスタンスで扱えます。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$entries1 = $resource-&gt;get-&gt;uri(&#39;app://self/entries&#39;)-&gt;eager-&gt;request();
$entries2 = $resource-&gt;get-&gt;uri(&#39;app://anohter_service/entries&#39;)-&gt;eager-&gt;request();
</code></pre></div>
<h2 id="toc_4">レガシーAPIのラップ</h2>

<p>レガシーなAPIをラップするとログや、キャッシュ、デバック画面などが利用できます。また抽象化されたAPIはリファクタリングも容易になりやすいのではないでしょうか。リソースアダプターをレガシーAPIのプロキシーとして実装します。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$entries1 = $resource-&gt;get-&gt;uri(&#39;office://self/room/resrvation/&#39;)-&gt;eager-&gt;request();
</code></pre></div>
<h2 id="toc_5">URIの可能性</h2>

<p>扱う情報に名前(URI)を与え全てを<code>API</code>をとして扱える様にすることはBEAR.Sundayの核心です。フレームワークによって固定化されたスキーマはなく、そのバインディングはアプリケーションドメインです。</p>

<p><code>URI</code>を持った情報はリソースAPIとして雑なシステムのハブとしても機能します。違うフレームワーク、違う言語、あるいは複数の種類のクライアント(Web / Mobile App / Console)や、ストレージの変更、R/Wでのストレージをの区別（CQRS)などす。それらの中心のハブとして機能する可能性があります。</p>

	</div>
</div>
 

			</div>
    	</div>
    	<div id="footer">
      		<div class="container">
        		<p class="text-muted credit">

        			Checkout BEAR.Sunday on <a href="https://github.com/koriym/BEAR.Sunday">Github</a>.

        		</p>
      		</div>
    	</div>
      <script type="text/javascript" src="/js/jquery.js"></script>
      <script type="text/javascript">
        $('table').addClass('table');
      </script>
    </body>
</html>